# Research 2: Critical Review Baseline

Ниже сохранён полный список проблем и замечаний, выявленных в ходе критичного анализа текущей реализации сети. Этот документ служит реперной точкой для последующих улучшений.

## Архитектура и API

- `NetworkConfig.environment(for:)` возвращает `.invalidURL`, если для домена не найден конфиг. Пользователь видит «битый URL», хотя реальная проблема — отсутствие конфигурации. Требуется отдельный `.missingEnvironment`.
- «Быстрый режим» `NetworkProvider.quick` жёстко фиксирует дефолтную сессию и не даёт подключать interceptors, storage, rate limiter и т.д., поэтому в реальных проектах им невозможно пользоваться.
- При добавлении query-параметров к POST/PUT/PATCH маршрутам строка запроса собирается вручную без URL-кодирования и без учёта уже существующих параметров, что приводит к ошибкам и утечкам.
- `Route.buildURL` сортирует query-параметры и теряет порядок/дубликаты, что ломает подписи URL и сценарии с повторяющимися ключами.

## Надёжность и обработка ошибок

- Retry-логика ограничена тайм-аутами и потерей соединения. HTTP 5xx и TLS-ошибки не ретраятся без кастомных интерсепторов, что противоречит обещанию «решать сложные задачи из коробки».
- После исчерпания попыток возвращается `.unknown(NSError(domain:"NetworkProvider", code:-1))`, из-за чего теряется исходная причина и затрудняется отладка.
- На Linux параметр `delegate` игнорируется: используется `dataTask(with:)` без делегата, хотя публичное API обещает поддержку прогресса и challenge callbacks.
- `TokenStorage` синхронно читает и молча подавляет ошибки сериализации (`try? token.encode()`), в результате токен может не сохраниться без каких-либо сигналов для пользователя.

## Потокобезопасность и отмена

- `try? await Task.sleep(...)` в нескольких местах глотает отмену (в экспоненциальной паузе `request()` и внутри `RateLimiter`), из-за чего задачи продолжают выполняться после отмены и могут повторно обращаться к API.
- `RateLimiter` каждый раз фильтрует весь массив таймстемпов, что создаёт сложность O(n²) и превращается в bottleneck под нагрузкой. Требуется кольцевой буфер или deque.
- `AuthenticationInterceptor` и `CookieAuthenticationInterceptor` бесконечно пытаются обновить токен при любом 401, отсутствуют счётчики попыток и backoff, что может превратить библиотеку в DoS на auth-сервер.

## Соответствие декларируемым возможностям

- «Низкий порог входа» не достигается: ошибки конфигурации маскируются под `.invalidURL`, quick-режим бесполезен, а query-параметры нужно экранировать вручную.
- Заявленная потокобезопасность не соблюдается из-за подавления отмен и бесконечных ретраев: акторы продолжают работать после завершения вызывающего `Task`.

Эти выводы отражают текущее состояние библиотеки и формируют список приоритетных задач для достижения уровня качества 10/10.
